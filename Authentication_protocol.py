from rsa import PublicKey, PrivateKey, encrypt, decrypt, sign_hash
from hashlib import sha256
import BlockChain
from time import time
import Random_String


class Authenticate:
    def __init__(self):
        self.pu_key = PublicKey(19735300506366648606809216260158404176991332663628844568568026082041291980614950071160539355137829291271188972558194742721953221513772994466286888523194228311787678838953845226430147092007785706549758818109192986816887331261903861953256462164040176658411001537549117573103140507145588122488253420778855640532181785964137645395870857136938675215567810046598271028199409003312375275298936097068677737339756232305563294718805792340951177321641782846630266963106739768917160296776963166674599827856065092425962157137181596241284820050081104622439052827918934452544173902432257458043382774342045732563308224737052453803991, 65537)
        self.block_address = ''
        self.req_pu_key = ''
        self.info()

    def info(self):
        self.block_address = input('Enter BlockChain Address: ').encode()
        self.block_address = encrypt(self.block_address, self.pu_key)
        """ 'crypto' is to be send through client to the miner."""
        """ Who will decrypt the msg using his private key"""
        #code to send this to miner through client
        self.miner_Side()

    def miner_Side(self):
        file_obj = open('miner_private_key.txt', 'r')
        arr = file_obj.read().split(',')
        file_obj.close()
        p_key = PrivateKey(int(arr[0]), int(arr[1]), int(arr[2]), int(arr[3]), int(arr[4]))
        try:
            self.block_address = int(decrypt(self.block_address, p_key))
        except:
            print('Error raised disconnecting the service')
            """If an error is raised here then the connection should be disconnected"""
            #code for disconnecting service and prompting user of failure

        self.req_pu_key = BlockChain.obj.blockchain[self.block_address]['auth_public_key'].split(',')
        self.verifier()

    def verifier(self):
        pu_key = PublicKey(int(self.req_pu_key[0]), int(self.req_pu_key[1]))
        nonce = Random_String.getRandomString() + str(time())
        hash_data = sha256(nonce.encode()).hexdigest().encode()
        crypto = encrypt(hash_data, pu_key)
        """This is the encrypted hash val generated by the verifier"""
        """This encrypted text is to be send across server to the requester"""
        """Remember if there is an error regarding 'TypeError' during transmission so inform me"""
        #Code to be written for sending data across server
        self.requester(crypto)

    def requester(self, encrypted_hash_val):
        private_key = open('private_key_rsa.txt', 'r').read().split(',')
        private_key = PrivateKey(int(private_key[0]), int(private_key[1]), int(private_key[2]), int(private_key[3]), int(private_key[4]))
        try:
            hash_val = decrypt(encrypted_hash_val, private_key)
        except:
            print('Not an Authentic User')
            """If an error is raised here then the connection should be disconnected"""
            # code for disconnecting service and prompting user of failure

        """ 'hash' to be sent to verifier through server and verifier checks data"""
        """ if data is same as sent data then authentication is sucessfull"""



Authenticate()